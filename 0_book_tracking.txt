//Book: Beginning Rust - Get Started with Rust 2021 Edition

Chapter 1: Getting Started
	1_1 How to Start
	1_2 Hello, World!
	1_3 Printing Combinations of Literals Strings
	1_4 Printing Several Lines of Text
	1_5 Printing Integer Numbers
	1_6 Comments

Chapter 2: Doing Arithmetics and Writing More Code
	2_1 Adding integer numbers
	2_2 Other operation with integers
	2_3 Floating-point Arithmetics 
	2_4 Sequences of Statements
	2_5 Breaking Literal Strings

Chapter 3: Naming Objects
	3_1 Associating names to vaues
	3_2 Multiple Variables
	3_3 Not Mutated Mutable Variables
	3_4 Unitialize Variables
	3_5 The leading underscore
	3_6 Boolean values
	3_7 Boolean Expressions
	3_8 Type Consistency < 
	3_9 Type Inference
	3_10 Change of type and of mutability
	3_11 Compound assigment Operators
	3_12 Using the functions of the standard library

Chapter 4: Controlling Execution Flow
	4_1 Conditional Statements
	4_2 Conditional Expressions
	4_3 Conditional Loops
	4_4 Infinite Loops
	4_5 Counting Loops
	4_6 Variable Scopes

Chapter 5: Using Data Sequences
	5_1 Arrays
	5_2 Rust Attributes
	5_3 Paniking
	5_4 Mutable Arrays
	5_5 Arrays of Explicitly Specified Size
	5_6 Multidimentional Arrays
	5_7 Vectors
	5_8 Vectors operations
	5_9 Empty Arrays and Vectors
	5_10 Debug Print
	5_11 Copying Arrays and Vectors

Chapter 06: Using Primitive Types	
	6_1 Nondecimal Numeric Bases
	6_2 The Underscore in Numeric Literals
	6_3 The Exponential Notation
	6_4 The Various Kinds of Signed Integer Numbers
	6_5 Unsigned Integer Number Types
	6_6 Target-Dependent Integer-Number Types
	6_7 Type Inference
	6_8 The Type Inference Algorithm
	6_9 Floating-Point Numeric Types
	6_10 Explicit Conversions
	6_11 Type Suffixes of Numeric Literals
	6_12 Booleans and Characters
	6_13 The Empty Tuple
	6_14 Array and Vector Types
	6_15 Constants
	6_16 Discovering the Type of an Expression

Chapter 07: Enumerations and Matching
	7_1 Enumerations
	7_2 The match Construct
	7_3 Relational Operators and Enums
	7_4 Handling All the Cases
	7_5 Using match with Numbers
	7_6 Enumerations with Data
	7_7 match Statements with Variables in Patterns
	7_8 match Expressions
	7_9 Use of Guards in match Constructs
	7_10 if-let and while-let Constructs

Chapter 08: Using Heterogeneous Data Structures
	8_1  The Tuples
	8_2  The Structs
	8_3  The Tuple-Struct
	8_4  Lexical Conventions

Chapter 09: Defining functions
	9_1 Defining and Invoking a Function
	9_2 Functions Defined After Their Use
	9_3 Functions Shadowing Other Functions
	9_4 Passing Arguments to a Function
	9_5 Passing Arguments by Value
	9_6 Returning a Value from a Function
	9_7 Early Exit
	9_8 Returning Several Values
	9_9 How to Change a Variable of the Caller
	9_10 Passing Arguments by Reference
	9_11 Using References
	9_12 Mutability of References

Chapter 10: Defining Generic Functions and Types
	10_1 Need of Generic Functions
	10_2 Defining and Using Generic Functions
	10_3 Inferring the Parametric Types
	10_4 Defining and Using Generic Structs
	10_5 Genericity Mechanics
	10_6 Generic Arrays and Vectors
	10_7 Generic Enums
	10_8 The Option<T> Standard Enum
	10_9 The Result<T, E> Standard Enum
	10_10 Enum Standard Utility Functions

Chapter 11: Allocating Memory
	11_1 The Various Kinds of Allocation
	11_2
	11_3
	11_4
	11_5
	11_6
	11_7
	11_8
	11_9
	11_10
	11_11 Register Allocation